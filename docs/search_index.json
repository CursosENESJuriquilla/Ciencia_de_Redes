[["fundamentos-de-teoría-de-redes.html", "Sección 2 Fundamentos de Teoría de Redes 2.1 Matriz de Adyacencia 2.2 Redes con pesos 2.3 Redes dirigidas 2.4 Graficas acíclicas 2.5 Redes k-regulares 2.6 Multigrafos (multiaristas) 2.7 Loops (lazos) 2.8 Redes bipartitas 2.9 Árboles 2.10 Gráficas planas 2.11 Grado y grado medio 2.12 Densidad 2.13 Redes multicapa 2.14 Redes dinámicas 2.15 Caminos y trayectorias 2.16 Trayectorias más cortas 2.17 Componentes conexas 2.18 Trayectorias independientes 2.19 Conjuntos de corte", " Sección 2 Fundamentos de Teoría de Redes library(reticulate) Primero, tenemos que importar algunas de las librerías básicas. networkx es la librería básica de redes en Python. pandas y numpy son básicas para manipulación de bases de datos y arreglos. matplotlib.pyplot es la básica para hacer plots. import pandas as pd import numpy as np import networkx as nx import matplotlib.pyplot as plt Una de las formas de definir una gráfica en Python es crear primero un objeto gráfica y después ir agregando los vértices y aristas. Al crear el objeto, se generará una gráfica vacía. G = nx.Graph() Podemos agregar nodos de uno en uno, por medio de una lista y las aristas es similar, podemos especificar entre que nodos están. # Un solo nodo G.add_node(1) # Dos nodos como lista G.add_nodes_from([2,3]) # Arista entre nodo 1 y 2 G.add_edge(1, 2) # Arista entre nodo 2 y 3 e = (2,3) G.add_edge(*e) Algo que queremos hacer, es poder visualizar estas gráficas. nx.draw(G, pos=nx.circular_layout(G), node_color=&#39;r&#39;, edge_color=&#39;b&#39;, with_labels=True) Vamos a crear otras gráficas. MyGraph = nx.Graph() MyGraph.add_edge(&#39;Antonio&#39;, &#39;Valentina&#39;) MyGraph.add_edge(&#39;Antonio&#39;, &#39;Claudia&#39;) MyGraph.add_edge(&#39;Claudia&#39;,&#39;Valentina&#39;) print(MyGraph) # Imprimir información de la gráfica ## Graph with 3 nodes and 3 edges print(&#39;Número de vértices&#39;, len(MyGraph.nodes)) ## Número de vértices 3 print(&#39;Número de aristas&#39;, len(MyGraph.edges)) ## Número de aristas 3 nx.draw_networkx(MyGraph, font_size=7) Existen varios atributos que podemos usar para dibujar la red. Por ejemplo:nx.draw_circular, nx.draw_planar, nx.draw_random, nx.draw_spectral, nx.draw_spring, nx.draw_shell. nx.draw_planar(MyGraph, with_labels = True, font_size=10, node_color=&#39;red&#39;, edge_color=&#39;blue&#39;) Vamos a construir una red simétrica. Los pesos pueden añadir intensidad de la relación en los nodos, cada arista tendrá un peso. Para gráficas dirigidas se usa nx.DiGraph(). DG = nx.DiGraph() # Agregamos nodos y aristas DG.add_nodes_from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]) DG.add_edges_from([(&quot;A&quot;, &quot;B&quot;), (&quot;B&quot;, &quot;C&quot;)]) # Dibujamos la gráfica nx.draw_networkx(DG, font_size=7) Y podemos crear una gráfica con pesos como sigue. WG = nx.Graph() # Agregamos nodos y aristas WG.add_edge(&quot;A&quot;, &quot;B&quot;, weight=3) WG.add_edge(&quot;B&quot;, &quot;C&quot;, weight=2) WG.add_edge(&quot;C&quot;, &quot;A&quot;, weight=1) # Dibujamos la gráfica nx.draw_networkx(WG, font_size=7) Sin embargo, si queremos que salga el peso, hay que modificar la forma de dibujarla. WG2 = nx.Graph() WG2.add_node(&quot;A&quot;, pos=(1,1)) WG2.add_node(&quot;B&quot;, pos=(2,2)) WG2.add_node(&quot;C&quot;, pos=(1,0)) WG2.add_edge(&quot;A&quot;,&quot;B&quot;,weight=0.5) WG2.add_edge(&quot;A&quot;,&quot;C&quot;,weight=9.8) pos=nx.get_node_attributes(WG2,&#39;pos&#39;) nx.draw(WG2,pos) labels = nx.get_edge_attributes(WG2,&#39;weight&#39;) nx.draw_networkx_edge_labels(WG2,pos,edge_labels=labels) ## {(&#39;A&#39;, &#39;B&#39;): Text(1.499993978679413, 1.499993978679413, &#39;0.5&#39;), (&#39;A&#39;, &#39;C&#39;): Text(1.0, 0.49999868113081897, &#39;9.8&#39;)} Si tenemos ya una base de datos, vista como un data frame, podemos construir su gráfica también tomando la información de esta. df = pd.DataFrame({ &#39;from&#39;:[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;,&#39;A&#39;], &#39;to&#39;:[&#39;D&#39;, &#39;A&#39;, &#39;E&#39;,&#39;C&#39;]}) G=nx.from_pandas_edgelist(df, &#39;from&#39;, &#39;to&#39;) nx.draw(G, with_labels=True) 2.1 Matriz de Adyacencia Las gráficas en networkx, las podemos crear también a partir de su matriz de adyacencia. Supongamos que tenemos la siguiente matriz de adyacencia de una gráfica. adjacency_matrix = np.array([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0]]) print(adjacency_matrix) ## [[0 1 1 0] ## [1 0 0 1] ## [1 0 0 0] ## [1 1 0 0]] Vamos a usar esta matriz para crear la gráfica. G = nx.Graph(adjacency_matrix, nodetype=int) print(G.edges()) ## [(0, 1), (0, 2), (0, 3), (1, 3)] nx.draw(G, with_labels=True) Y esta misma matriz, la podríamos usar para generar la red dirigida. G = nx.DiGraph(adjacency_matrix, nodetype=int) print(G.edges()) ## [(0, 1), (0, 2), (1, 0), (1, 3), (2, 0), (3, 0), (3, 1)] nx.draw(G, with_labels=True) 2.2 Redes con pesos En muchas aplicaciones, no basta saber si dos nodos están conectados: queremos medir intensidad. Ejemplo: ciudades conectadas por tiempo de traslado. G = nx.Graph() edges = [ (&quot;CDMX&quot;, &quot;Querétaro&quot;, 2.5), (&quot;CDMX&quot;, &quot;Puebla&quot;, 1.8), (&quot;Querétaro&quot;, &quot;San Luis&quot;, 3.0), (&quot;Puebla&quot;, &quot;Veracruz&quot;, 2.2) ] G.add_weighted_edges_from(edges) pos = nx.spring_layout(G, seed=42) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=&quot;lightblue&quot;) labels = nx.get_edge_attributes(G, &quot;weight&quot;) nx.draw_networkx_edge_labels(G, pos, edge_labels=labels) ## {(&#39;CDMX&#39;, &#39;Querétaro&#39;): Text(-0.03804987394440071, 0.29044345796704585, &#39;2.5&#39;), (&#39;CDMX&#39;, &#39;Puebla&#39;): Text(0.03310940855012143, -0.2517211871628955, &#39;1.8&#39;), (&#39;Querétaro&#39;, &#39;San Luis&#39;): Text(-0.09868076835080415, 0.7517180744260015, &#39;3.0&#39;), (&#39;Puebla&#39;, &#39;Veracruz&#39;): Text(0.10107661635624102, -0.7703266027551717, &#39;2.2&#39;)} plt.title(&quot;Red con pesos (horas de traslado)&quot;) plt.show() nx.spring_layout: Cuando dibujas una red, necesitas decidir dónde se coloca cada nodo en el plano (coordenadas (x,y)). nx.spring_layout(G) calcula esas posiciones automáticamente usando un modelo tipo resortes: cada arista actúa como un resorte que “jala” a sus extremos para acercarlos, los nodos se repelen entre sí para que no queden amontonados, el algoritmo busca una configuración “bonita” (pocas intersecciones, distancias razonables). No cambia el grafo, solo produce un diccionario de posiciones. pos = nx.spring_layout(G, seed=42) print(pos) ## {&#39;CDMX&#39;: array([-0.00479153, 0.03721578]), &#39;Querétaro&#39;: array([-0.07130957, 0.54368146]), &#39;Puebla&#39;: array([ 0.07100945, -0.54065133]), &#39;San Luis&#39;: array([-0.12605188, 0.95975409]), &#39;Veracruz&#39;: array([ 0.13114354, -1. ])} Ejercicio: Comparar con nx.circular_layout(G) para ver que “layout” = regla de colocación. 2.3 Redes dirigidas En una red dirigida las aristas tienen orientación. Ejemplo: prerequisitos de materias. DG = nx.DiGraph() DG.add_edge(&quot;Álgebra I&quot;, &quot;Álgebra II&quot;) DG.add_edge(&quot;Álgebra II&quot;, &quot;Geometría&quot;) DG.add_edge(&quot;Cálculo I&quot;, &quot;Cálculo II&quot;) pos = nx.spring_layout(DG, seed=10) nx.draw(DG, pos, with_labels=True, node_size=2500, node_color=&quot;lightcoral&quot;, arrows=True, arrowsize=20) plt.title(&quot;Red dirigida (prerrequisitos)&quot;) plt.show() Grado en redes dirigidas In-degree: número de aristas que llegan. Out-degree: número de aristas que salen. print(&quot;In-degree:&quot;, dict(DG.in_degree())) ## In-degree: {&#39;Álgebra I&#39;: 0, &#39;Álgebra II&#39;: 1, &#39;Geometría&#39;: 1, &#39;Cálculo I&#39;: 0, &#39;Cálculo II&#39;: 1} print(&quot;Out-degree:&quot;, dict(DG.out_degree())) ## Out-degree: {&#39;Álgebra I&#39;: 1, &#39;Álgebra II&#39;: 1, &#39;Geometría&#39;: 0, &#39;Cálculo I&#39;: 1, &#39;Cálculo II&#39;: 0} 2.4 Graficas acíclicas Un grafo dirigido es acíclico si no contiene ciclos. DAG = nx.DiGraph() DAG.add_edges_from([ (1,2), (1,3), (2,4), (3,4) ]) print(&quot;¿Es DAG?&quot;, nx.is_directed_acyclic_graph(DAG)) ## ¿Es DAG? True Ordenamiento topológico: list(nx.topological_sort(DAG)) ## [1, 2, 3, 4] Si numeramos los vértices según ese orden, la matriz de adyacencia queda triangular superior. En un grafo dirigido sin ciclos, existe un orden de los vértices tal que todas las aristas van “hacia adelante” en ese orden. nx.topological_sort devuelve ese orden. order = list(nx.topological_sort(DAG)) print(order) ## [1, 2, 3, 4] Si reetiquetas/ordenas los vértices según ese orden y construyes la matriz de adyacencia en ese orden, la matriz queda triangular superior. Por ejemplo: DAG = nx.DiGraph() DAG.add_edges_from([(1,2),(1,3),(2,4),(3,4)]) order = list(nx.topological_sort(DAG)) print(&quot;Orden topológico:&quot;, order) ## Orden topológico: [1, 2, 3, 4] A = nx.to_numpy_array(DAG, nodelist=order, dtype=int) print(&quot;Matriz en ese orden:\\n&quot;, A) ## Matriz en ese orden: ## [[0 1 1 0] ## [0 0 0 1] ## [0 0 0 1] ## [0 0 0 0]] A_weird = A.T print(A_weird) ## [[0 0 0 0] ## [1 0 0 0] ## [1 0 0 0] ## [0 1 1 0]] 2.5 Redes k-regulares Un grafo es \\(k\\)-regular si todos los vértices tienen grado \\(k\\). R = nx.random_regular_graph(d=3, n=8) nx.draw(R, with_labels=True, node_size=1500) plt.title(&quot;Grafo 3-regular&quot;) plt.show() 2.6 Multigrafos (multiaristas) En algunos sistemas pueden existir varias relaciones entre dos nodos. Ejemplo: dos actores que colaboran en varias películas. MG = nx.MultiGraph() MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 0 MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 1 MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 2 print(&quot;Número de aristas entre A y B:&quot;, MG.number_of_edges(&quot;A&quot;,&quot;B&quot;)) ## Número de aristas entre A y B: 3 Y para visualziarla: pos = nx.spring_layout(MG, seed=3) nx.draw(MG, pos, with_labels=True, node_size=2000) plt.title(&quot;MultiGraph&quot;) plt.show() Para que se vea que hay varias aristas entre los mismos nodos, usamos connectionstyle con distintos radios. MG = nx.MultiGraph() MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 0 MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 1 MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 2 MG.add_edge(&quot;B&quot;,&quot;C&quot;) ## 0 pos = nx.spring_layout(MG, seed=2) # Dibujo de nodos nx.draw_networkx_nodes(MG, pos, node_size=2000, node_color=&quot;lightgreen&quot;) nx.draw_networkx_labels(MG, pos) ## {&#39;A&#39;: Text(0.8284668313118051, -0.8726270765014832, &#39;A&#39;), &#39;B&#39;: Text(0.12093500309378266, -0.1273729234985168, &#39;B&#39;), &#39;C&#39;: Text(-0.949401834405588, 1.0, &#39;C&#39;)} # Dibujo de aristas: si son paralelas, usamos curvaturas distintas edges = list(MG.edges(keys=True)) for i, (u, v, k) in enumerate(edges): rad = 0.15 * (i % 3) # radios 0, 0.15, 0.30 (repite) nx.draw_networkx_edges( MG, pos, edgelist=[(u, v)], width=2, connectionstyle=f&quot;arc3,rad={rad}&quot;, edge_color=&quot;gray&quot; ) plt.title(&quot;MultiGraph con multiaristas (arcos curvos)&quot;) plt.axis(&quot;off&quot;) ## (np.float64(-1.0962567812307198), np.float64(0.9571815276728693), np.float64(-1.0082027056679594), np.float64(1.1546815676912536)) plt.show() print(&quot;Número de aristas A-B:&quot;, MG.number_of_edges(&quot;A&quot;,&quot;B&quot;)) ## Número de aristas A-B: 3 2.7 Loops (lazos) Un loop es una arista de un nodo a sí mismo. G = nx.Graph() G.add_edge(&quot;A&quot;,&quot;A&quot;) # loop G.add_edge(&quot;A&quot;,&quot;B&quot;) print(&quot;Grados:&quot;, dict(G.degree())) ## Grados: {&#39;A&#39;: 3, &#39;B&#39;: 1} Importante: En grafos no dirigidos, un loop contribuye 2 al grado. NetworkX dibuja loops como “arcos” pequeños, pero a veces quedan discretos. G = nx.Graph() G.add_edges_from([(&quot;A&quot;,&quot;A&quot;), (&quot;A&quot;,&quot;B&quot;), (&quot;B&quot;,&quot;C&quot;), (&quot;C&quot;,&quot;C&quot;)]) # loops en A y C pos = nx.spring_layout(G, seed=4) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=&quot;lightblue&quot;, width=2, edge_color=&quot;gray&quot;) plt.title(&quot;Grafo con loops en A y C&quot;) plt.show() También podemos listarlos: print(&quot;Loops:&quot;, list(nx.selfloop_edges(G))) ## Loops: [(&#39;A&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;C&#39;)] 2.8 Redes bipartitas Ejemplo: películas y actores. data = { &quot;Movie&quot;: [&quot;Matrix&quot;,&quot;Matrix&quot;,&quot;Titanic&quot;,&quot;Titanic&quot;,&quot;Inception&quot;], &quot;Actor&quot;: [&quot;Keanu&quot;,&quot;Carrie&quot;,&quot;Leonardo&quot;,&quot;Kate&quot;,&quot;Leonardo&quot;] } df = pd.DataFrame(data) Vamos a construirla: B = nx.Graph() movies = df[&quot;Movie&quot;].unique() actors = df[&quot;Actor&quot;].unique() B.add_nodes_from(movies, bipartite=0) B.add_nodes_from(actors, bipartite=1) B.add_edges_from([(row.Movie,row.Actor) for _,row in df.iterrows()]) nx.draw(B, with_labels=True, node_size=2000) plt.title(&quot;Red bipartita&quot;) plt.show() Otra forma de hacer el plot: pos = nx.bipartite_layout(B, movies) # movies será la capa superior nx.draw(B, pos, with_labels=True, node_size=2000, node_color=&quot;lightblue&quot;) plt.title(&quot;Red bipartita (películas arriba, actores abajo)&quot;) plt.show() Y se puede “forzar” también esto: movies = list(df[&quot;Movie&quot;].unique()) actors = list(df[&quot;Actor&quot;].unique()) pos = {} # Películas arriba (y=1) for i, movie in enumerate(movies): pos[movie] = (i, 1) # Actores abajo (y=0) for i, actor in enumerate(actors): pos[actor] = (i, 0) nx.draw(B, pos, with_labels=True, node_size=2000, node_color=&quot;lightyellow&quot;, edge_color=&quot;gray&quot;) plt.title(&quot;Red bipartita forzada (arriba películas, abajo actores)&quot;) plt.ylim(-0.5, 1.5) ## (-0.5, 1.5) plt.show() Otra forma más, coloreando cada capa: color_map = [] for node in B.nodes(): if node in movies: color_map.append(&quot;lightcoral&quot;) else: color_map.append(&quot;lightblue&quot;) nx.draw(B, pos, with_labels=True, node_color=color_map, node_size=2000) plt.title(&quot;Red bipartita con capas diferenciadas&quot;) plt.show() 2.8.1 Matriz de incidencia B_matrix = np.zeros((len(movies), len(actors))) for _,row in df.iterrows(): i = list(movies).index(row.Movie) j = list(actors).index(row.Actor) B_matrix[i,j] = 1 print(B_matrix) ## [[1. 1. 0. 0.] ## [0. 0. 1. 1.] ## [0. 0. 1. 0.]] 2.8.2 Proyección one-mode W = B_matrix.T @ B_matrix print(W) ## [[1. 1. 0. 0.] ## [1. 1. 0. 0.] ## [0. 0. 2. 1.] ## [0. 0. 1. 1.]] from networkx.algorithms import bipartite df = pd.DataFrame({ &quot;Movie&quot;: [&quot;Matrix&quot;,&quot;Matrix&quot;,&quot;Titanic&quot;,&quot;Titanic&quot;,&quot;Inception&quot;], &quot;Actor&quot;: [&quot;Keanu&quot;,&quot;Carrie&quot;,&quot;Leonardo&quot;,&quot;Kate&quot;,&quot;Leonardo&quot;] }) movies = list(df[&quot;Movie&quot;].unique()) actors = list(df[&quot;Actor&quot;].unique()) # Grafo bipartito B = nx.Graph() B.add_nodes_from(movies, bipartite=0) B.add_nodes_from(actors, bipartite=1) B.add_edges_from([(row.Movie, row.Actor) for _, row in df.iterrows()]) # Posiciones forzadas (películas arriba, actores abajo) pos = {} for i, m in enumerate(movies): pos[m] = (i, 1) for i, a in enumerate(actors): pos[a] = (i, 0) # Colores por capa node_colors = [&quot;lightcoral&quot; if n in movies else &quot;lightblue&quot; for n in B.nodes()] nx.draw(B, pos, with_labels=True, node_color=node_colors, node_size=2000, edge_color=&quot;gray&quot;) plt.title(&quot;Bipartita: películas (arriba) – actores (abajo)&quot;) ## Text(0.5, 1.0, &#39;Bipartita: películas (arriba) – actores (abajo)&#39;) plt.ylim(-0.6, 1.6) ## (-0.6, 1.6) plt.axis(&quot;off&quot;) ## (np.float64(-0.31500000000000006), np.float64(3.315), np.float64(-0.6), np.float64(1.6)) plt.show() Vamos a crear las dos proyecciones. 2.8.3 Proyección one-mode a Actores # Proyección a actores (one-mode) P_actors = bipartite.weighted_projected_graph(B, actors) print(&quot;Aristas (actor-actor) con pesos:&quot;, list(P_actors.edges(data=True))) ## Aristas (actor-actor) con pesos: [(&#39;Keanu&#39;, &#39;Carrie&#39;, {&#39;weight&#39;: 1}), (&#39;Leonardo&#39;, &#39;Kate&#39;, {&#39;weight&#39;: 1})] posA = nx.spring_layout(P_actors, seed=12) nx.draw(P_actors, posA, with_labels=True, node_size=2000, node_color=&quot;lightblue&quot;, edge_color=&quot;gray&quot;) # Etiquetas de peso labelsA = nx.get_edge_attributes(P_actors, &quot;weight&quot;) nx.draw_networkx_edge_labels(P_actors, posA, edge_labels=labelsA) ## {(&#39;Keanu&#39;, &#39;Carrie&#39;): Text(-0.35775095734238305, 0.19487556024727604, &#39;1&#39;), (&#39;Leonardo&#39;, &#39;Kate&#39;): Text(0.3577635707881759, -0.19487292868700534, &#39;1&#39;)} plt.title(&quot;Proyección one-mode: red de actores (peso = películas compartidas)&quot;) ## Text(0.5, 1.0, &#39;Proyección one-mode: red de actores (peso = películas compartidas)&#39;) plt.axis(&quot;off&quot;) ## (np.float64(-0.9375232965348552), np.float64(1.184108548539511), np.float64(-0.699174762922632), np.float64(1.0700229118070153)) plt.show() 2.8.4 Proyección one-mode a PELÍCULAS # Proyección a películas (one-mode) P_movies = bipartite.weighted_projected_graph(B, movies) print(&quot;Aristas (movie-movie) con pesos:&quot;, list(P_movies.edges(data=True))) ## Aristas (movie-movie) con pesos: [(&#39;Titanic&#39;, &#39;Inception&#39;, {&#39;weight&#39;: 1})] posM = nx.spring_layout(P_movies, seed=12) nx.draw(P_movies, posM, with_labels=True, node_size=2300, node_color=&quot;lightcoral&quot;, edge_color=&quot;gray&quot;) labelsM = nx.get_edge_attributes(P_movies, &quot;weight&quot;) nx.draw_networkx_edge_labels(P_movies, posM, edge_labels=labelsM) ## {(&#39;Titanic&#39;, &#39;Inception&#39;): Text(-0.5000007838353786, -0.32225756924227716, &#39;1&#39;)} plt.title(&quot;Proyección one-mode: red de películas (peso = actores compartidos)&quot;) ## Text(0.5, 1.0, &#39;Proyección one-mode: red de películas (peso = actores compartidos)&#39;) plt.axis(&quot;off&quot;) ## (np.float64(-0.7473488387186665), np.float64(1.0832070875580317), np.float64(-0.6374842965559769), np.float64(0.7055652738076293)) plt.show() Si \\(B\\) es la matriz de incidencia (películas × actores), entonces: \\(B^TB\\): co-ocurrencia actor–actor \\(BB^T\\): co-ocurrencia película–película # Matriz de incidencia: filas=películas, columnas=actores Bmat = np.zeros((len(movies), len(actors)), dtype=int) movie_idx = {m:i for i,m in enumerate(movies)} actor_idx = {a:j for j,a in enumerate(actors)} for _, row in df.iterrows(): Bmat[movie_idx[row.Movie], actor_idx[row.Actor]] = 1 print(&quot;B (películas x actores):\\n&quot;, Bmat) ## B (películas x actores): ## [[1 1 0 0] ## [0 0 1 1] ## [0 0 1 0]] W_actors = Bmat.T @ Bmat # actores x actores W_movies = Bmat @ Bmat.T # películas x películas print(&quot;\\nB^T B (actores x actores):\\n&quot;, W_actors) ## ## B^T B (actores x actores): ## [[1 1 0 0] ## [1 1 0 0] ## [0 0 2 1] ## [0 0 1 1]] print(&quot;\\nB B^T (películas x películas):\\n&quot;, W_movies) ## ## B B^T (películas x películas): ## [[2 0 0] ## [0 2 1] ## [0 1 1]] 2.9 Árboles En Python, podemos crear árboles con la instrucción nx.path_graph(n) T = nx.path_graph(6) nx.draw(T, with_labels=True) Podemos verificar si una gráfica dada es un árbol, al verificar la condición de que \\(|E| = |V|-1\\). n = T.number_of_nodes() m = T.number_of_edges() print(&quot;Nodos:&quot;, n) ## Nodos: 6 print(&quot;Aristas:&quot;, m) ## Aristas: 5 print(&quot;¿Cumple m = n-1?&quot;, m == n-1) ## ¿Cumple m = n-1? True Ejercicio: Genera un cycle_graph(6). Verifica si es un árbol. Elimina una arista y vuelve a verificar. Veamos otros algoritmos de networkx para generar árboles. prefix_tree: Un “árbol de prefijos” representa la estructura de prefijos de las cadenas. Cada nodo representa un prefijo de alguna cadena. La raíz representa el prefijo vacío con hijos para los prefijos de una sola letra, que a su vez tienen hijos para cada prefijo de dos letras, comenzando con la letra correspondiente al nodo padre, y así sucesivamente. Añade artificialmente dos nodos, el nodo raíz y el nodo NIL. El nodo raíz siempre es 0 y su atributo de origen es “Ninguno”. Es el único nodo con grado de entrada cero. El nodo nulo siempre es -1 y su atributo de origen es “NIL”. Es el único nodo con grado de salida cero. paths = [&quot;ab&quot;, &quot;abs&quot;, &quot;ad&quot;] T = nx.prefix_tree(paths) list(T.edges) ## [(0, 1), (1, 2), (1, 4), (2, -1), (2, 3), (3, -1), (4, -1)] nx.draw(T, with_labels= True) nx.is_tree(T) ## False T.remove_node(-1) nx.draw(T, with_labels= True) nx.is_tree(T) ## True Podemos recuperar las trayectorias que teníamos. paths = [&quot;ab&quot;, &quot;abs&quot;, &quot;ad&quot;] T = nx.prefix_tree(paths) root, NIL = 0, -1 recovered = [] for v in T.predecessors(NIL): prefix = &quot;&quot; while v != root: prefix = str(T.nodes[v][&quot;source&quot;]) + prefix v = next(T.predecessors(v)) # only one predecessor recovered.append(prefix) sorted(recovered) ## [&#39;ab&#39;, &#39;abs&#39;, &#39;ad&#39;] random_labeled_tree: G = nx.random_labeled_tree(5, seed=42) nx.is_tree(G) ## True nx.draw(G, with_labels = True) DG = nx.DiGraph() DG.add_edges_from(G.edges) nx.is_tree(DG) ## True nx.draw(DG, with_labels = True) random_labeled_rooted_forest: F = nx.random_labeled_rooted_forest(10, seed = 42) nx.is_forest(F) ## True nx.draw(F, with_labels = True) random_unlabeled_rooted_forest #F2 = nx.random_unlabeled_rooted_forest(10, number_of_forests=3, seed = 42) #nx.is_forest(F2) #nx.draw(F2, with_labels = True) 2.10 Gráficas planas Con la función nx.check_planarity(Graph_object) podemos verificar si una red es plana o no. G1 = nx.cycle_graph(5) nx.check_planarity(G1) ## (True, &lt;networkx.algorithms.planarity.PlanarEmbedding object at 0x0000020EFB920E10&gt;) G2 = nx.complete_graph(6) nx.draw(G2, with_labels=True) is_planar, P = nx.check_planarity(G2, counterexample=True) print(is_planar) ## False nx.draw(P, with_labels=True) Ejercicio: Verifica la planaridad de complete_graph(4) y complete_graph(5). 2.11 Grado y grado medio G = nx.cycle_graph(6) dict(G.degree()) ## {0: 2, 1: 2, 2: 2, 3: 2, 4: 2, 5: 2} G.degree[1] ## 2 El grado medio lo podemos obtener de la siguiente forma: deg_values = [d for n,d in G.degree()] c = np.mean(deg_values) print(&quot;EL grado medio c es igual a &quot;, c) ## EL grado medio c es igual a 2.0 Teóricamente, el grado medio cumple que \\(c=\\frac{2m}{n}\\), donde \\(m\\) es el número de aristas y \\(n\\) el número de vértices. n = G.number_of_nodes() m = G.number_of_edges() v = 2*m/n print(&#39;Se cumple la relación c=2m/n&#39;, c == v) ## Se cumple la relación c=2m/n True Ejercicio: Crea una complete_graph(8), calcula el grado medio y comparalo con la fórmula teórica. 2.12 Densidad Para una red no dirigida, tenemos lo siguiente: G = nx.path_graph(10) nx.density(G) ## 0.2 Para el caso de una red dirigida, DG = nx.DiGraph() DG.add_edges_from([(1,2),(2,3),(3,4)]) nx.density(DG) ## 0.25 Ejemplo: Compara la desidad de las gráficas path_graph(20) y complete_graph(20). ¿Cuál es sparse y cuál densa? 2.12.1 Sparsidad y crecimiento for n in [20,50,100]: G = nx.path_graph(n) print(&quot;n =&quot;, n, &quot;densidad =&quot;, nx.density(G)) ## n = 20 densidad = 0.1 ## n = 50 densidad = 0.04 ## n = 100 densidad = 0.02 2.13 Redes multicapa G = nx.Graph() G.add_edge(&quot;Ana&quot;,&quot;Luis&quot;, layer=&quot;amistad&quot;) G.add_edge(&quot;Ana&quot;,&quot;Luis&quot;, layer=&quot;trabajo&quot;) G.edges(data=True) ## EdgeDataView([(&#39;Ana&#39;, &#39;Luis&#39;, {&#39;layer&#39;: &#39;trabajo&#39;})]) nx.draw(G) Ejercicio: ¿Cómo cambiaría el grado si consideramos cada capa por separado? 2.14 Redes dinámicas G_t1 = nx.Graph() G_t1.add_edges_from([(1,2),(2,3)]) G_t2 = nx.Graph() G_t2.add_edges_from([(1,2),(2,4)]) print(&quot;Densidad t1:&quot;, nx.density(G_t1)) ## Densidad t1: 0.6666666666666666 print(&quot;Densidad t2:&quot;, nx.density(G_t2)) ## Densidad t2: 0.6666666666666666 2.15 Caminos y trayectorias G = nx.Graph() G.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) nx.draw(G, with_labels=True) Podemos listas todos los posibles caminos simples(sin vértices repetidos): list(nx.all_simple_paths(G, source=1, target=5)) ## [[1, 2, 3, 4, 5], [1, 2, 4, 5]] Se puede demostrar que que un camino simple se puede encontrar en tiempo \\(O(V+E)\\) pero el número de trayectorias simples puede ser muy grande, por ejemplo para gráficas completas de orden \\(n\\) es de tiempo \\(O(n!)\\). Uno puede especificar trayectorias de longitud \\(r\\) como sigue: G = nx.complete_graph(4) paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2) print(list(paths)) ## [[0, 1, 3], [0, 2, 3], [0, 3]] Y podemos obtenerlas también como la lista de aristas: paths = nx.all_simple_paths(G, source=0, target=3) for path in map(nx.utils.pairwise, paths): print(list(path)) ## [(0, 1), (1, 2), (2, 3)] ## [(0, 1), (1, 3)] ## [(0, 2), (2, 1), (1, 3)] ## [(0, 2), (2, 3)] ## [(0, 3)] Podríamos también fijar solo uno de los nodos y el otro variarlo: G = nx.complete_graph(4) for path in nx.all_simple_paths(G, source=0, target=[3, 2]): print(path) ## [0, 1, 2] ## [0, 1, 2, 3] ## [0, 1, 3] ## [0, 1, 3, 2] ## [0, 2] ## [0, 2, 1, 3] ## [0, 2, 3] ## [0, 3] ## [0, 3, 1, 2] ## [0, 3, 2] La trayectoria que va de un vértice a si mismo de tamaño 0: G = nx.empty_graph(5) list(nx.all_simple_paths(G, source=0, target=0)) ## [[0]] G = nx.path_graph(3) list(nx.all_simple_paths(G, source=0, target={0, 1, 2})) ## [[0], [0, 1], [0, 1, 2]] Podemos contar las trayectorias de una raíz a sus hojas en una gráfica dirigida acíclica. G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)]) roots = (v for v, d in G.in_degree() if d == 0) leaves = (v for v, d in G.out_degree() if d == 0) all_paths = [] for root in roots: for leaf in leaves: paths = nx.all_simple_paths(G, root, leaf) all_paths.extend(paths) all_paths ## [[0, 1, 2], [0, 3, 2]] Iterar sobre cada ruta desde los nodos raíz a los nodos hoja en un gráfico acíclico dirigido pasando todas las hojas juntas para evitar cálculos innecesarios: G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)]) roots = (v for v, d in G.in_degree() if d == 0) leaves = [v for v, d in G.out_degree() if d == 0] all_paths = [] for root in roots: paths = nx.all_simple_paths(G, root, leaves) all_paths.extend(paths) all_paths ## [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]] En las multigráficas, es decir si tenemos aristas paralelas, nos va a regresar las trayectorias múltiple veces: G = nx.MultiDiGraph([(0, 1), (0, 1), (1, 2)]) list(nx.all_simple_paths(G, 0, 2)) ## [[0, 1, 2], [0, 1, 2]] Como decíamos antes, el tiempo en el que encuentra caminos simples puede ser muy grande, entonces es recomendado preguntarse primero si existen caminos entre dos nodos. G1 = nx.Graph() G1.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) nx.has_path(G1, 1, 4) ## True G2 = nx.Graph() G2.add_edges_from([(1, 2), (2, 3), (4, 5)]) # nodo 1 y nodo 3 path_exists_1_to_3 = nx.has_path(G2, 1, 3) print(f&quot;Existe una trayectoria de 1 a 3: {path_exists_1_to_3}&quot;) # Nodo 1 y nodo 4 path_exists_1_to_4 = nx.has_path(G2, 1, 4) print(f&quot;Existe una trayectoria de 1 a 4: {path_exists_1_to_4}&quot;) Ejercicio: Construye una red que no tenga un camino entre dos nodos dados. Y usa la función has_path() para verificarlo. 2.16 Trayectorias más cortas G1 = nx.Graph() G1.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) nx.shortest_path(G1, source=1, target=4) ## [1, 2, 4] G1 = nx.Graph() G1.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) nx.shortest_path_length(G1, source=1, target=4) ## 2 Para el caso de gráficas con peso: WG = nx.Graph() WG.add_weighted_edges_from([ (1,2,1), (2,3,2), (1,3,5), (3,4,1) ]) nx.shortest_path(WG, source=1, target=4, weight=&quot;weight&quot;) ## [1, 2, 3, 4] Ejercicio: Modifica los pesos para que cambie el camino más corto. 2.17 Componentes conexas G = nx.Graph() G.add_edges_from([(1,2),(2,3),(4,5)]) nx.draw(G, with_labels=True) list(nx.connected_components(G)) ## [{1, 2, 3}, {4, 5}] nx.number_connected_components(G) ## 2 Para el caso de redes dirigidas, tenemos una forma de preguntar por las debilmente conectadas y las fuertemente conectadas. DG = nx.DiGraph() DG.add_edges_from([ (1,2), (2,3), (3,1), (3,4), (5,4) ]) list(nx.weakly_connected_components(DG)) ## [{1, 2, 3, 4, 5}] list(nx.strongly_connected_components(DG)) ## [{4}, {1, 2, 3}, {5}] Y para las In y Out componentes también: descendants(G, source): nos regresa todos los vértices que son alcanzables desde algún vértice source. ancestors(G, source): nos regresa todos los vértices que tienen una trayectoria al vértice source. nx.descendants(DG, 1) ## {2, 3, 4} nx.ancestors(DG, 1) ## {2, 3} 2.18 Trayectorias independientes Independientes por aristas: G1 = nx.Graph() G1.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) nx.edge_disjoint_paths(G1, 1, 4) ## &lt;generator object edge_disjoint_paths at 0x0000020EFA3A4CC0&gt; G1 = nx.Graph() G1.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) list(nx.edge_disjoint_paths(G1, 1, 4)) ## [[1, 2, 4]] Independientes por vértices: G1 = nx.Graph() G1.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) list(nx.node_disjoint_paths(G1, 1, 4)) ## [[1, 2, 4]] 2.19 Conjuntos de corte Conjunto de corte por aristas mínimo: G1 = nx.Graph() G1.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) nx.minimum_edge_cut(G1, 1, 4) ## {(1, 2)} Conjunto de corte por vértices mínimo: G1 = nx.Graph() G1.add_edges_from([ (1,2), (2,3), (3,4), (2,4), (4,5) ]) nx.minimum_node_cut(G1, 1, 4) ## {2} "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
