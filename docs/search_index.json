[["fundamentos-de-teoría-de-redes.html", "Sección 2 Fundamentos de Teoría de Redes", " Sección 2 Fundamentos de Teoría de Redes Primero, tenemos que importar algunas de las librerías básicas. networkx es la librería básica de redes en Python. pandas y numpy son básicas para manipulación de bases de datos y arreglos. matplotlib.pyplot es la básica para hacer plots. import pandas as pd import numpy as np import networkx as nx import matplotlib.pyplot as plt Una de las formas de definir una gráfica en Python es crear primero un objeto gráfica y después ir agregando los vértices y aristas. Al crear el objeto, se generará una gráfica vacía. G = nx.Graph() Podemos agregar nodos de uno en uno, por medio de una lista y las aristas es similar, podemos especificar entre que nodos están. # Un solo nodo G.add_node(1) # Dos nodos como lista G.add_nodes_from([2,3]) # Arista entre nodo 1 y 2 G.add_edge(1, 2) # Arista entre nodo 2 y 3 e = (2,3) G.add_edge(*e) Algo que queremos hacer, es poder visualizar estas gráficas. nx.draw(G, pos=nx.circular_layout(G), node_color=&#39;r&#39;, edge_color=&#39;b&#39;, with_labels=True) Vamos a crear otras gráficas. MyGraph = nx.Graph() MyGraph.add_edge(&#39;Antonio&#39;, &#39;Valentina&#39;) MyGraph.add_edge(&#39;Antonio&#39;, &#39;Claudia&#39;) MyGraph.add_edge(&#39;Claudia&#39;,&#39;Valentina&#39;) print(MyGraph) # Imprimir información de la gráfica ## Graph with 3 nodes and 3 edges print(&#39;Número de vértices&#39;, len(MyGraph.nodes)) ## Número de vértices 3 print(&#39;Número de aristas&#39;, len(MyGraph.edges)) ## Número de aristas 3 nx.draw_networkx(MyGraph, font_size=7) Existen varios atributos que podemos usar para dibujar la red. Por ejemplo:nx.draw_circular, nx.draw_planar, nx.draw_random, nx.draw_spectral, nx.draw_spring, nx.draw_shell. nx.draw_planar(MyGraph, with_labels = True, font_size=10, node_color=&#39;red&#39;, edge_color=&#39;blue&#39;) Vamos a construir una red simétrica. Los pesos pueden añadir intensidad de la relación en los nodos, cada arista tendrá un peso. Para gráficas dirigidas se usa nx.DiGraph(). DG = nx.DiGraph() # Agregamos nodos y aristas DG.add_nodes_from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]) DG.add_edges_from([(&quot;A&quot;, &quot;B&quot;), (&quot;B&quot;, &quot;C&quot;)]) # Dibujamos la gráfica nx.draw_networkx(DG, font_size=7) Y podemos crear una gráfica con pesos como sigue. WG = nx.Graph() # Agregamos nodos y aristas WG.add_edge(&quot;A&quot;, &quot;B&quot;, weight=3) WG.add_edge(&quot;B&quot;, &quot;C&quot;, weight=2) WG.add_edge(&quot;C&quot;, &quot;A&quot;, weight=1) # Dibujamos la gráfica nx.draw_networkx(WG, font_size=7) Sin embargo, si queremos que salga el peso, hay que modificar la forma de dibujarla. WG2 = nx.Graph() WG2.add_node(&quot;A&quot;, pos=(1,1)) WG2.add_node(&quot;B&quot;, pos=(2,2)) WG2.add_node(&quot;C&quot;, pos=(1,0)) WG2.add_edge(&quot;A&quot;,&quot;B&quot;,weight=0.5) WG2.add_edge(&quot;A&quot;,&quot;C&quot;,weight=9.8) pos=nx.get_node_attributes(WG2,&#39;pos&#39;) nx.draw(WG2,pos) labels = nx.get_edge_attributes(WG2,&#39;weight&#39;) nx.draw_networkx_edge_labels(WG2,pos,edge_labels=labels) ## {(&#39;A&#39;, &#39;B&#39;): Text(1.499993978679413, 1.499993978679413, &#39;0.5&#39;), (&#39;A&#39;, &#39;C&#39;): Text(1.0, 0.49999868113081897, &#39;9.8&#39;)} Si tenemos ya una base de datos, vista como un data frame, podemos construir su gráfica también tomando la información de esta. df = pd.DataFrame({ &#39;from&#39;:[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;,&#39;A&#39;], &#39;to&#39;:[&#39;D&#39;, &#39;A&#39;, &#39;E&#39;,&#39;C&#39;]}) G=nx.from_pandas_edgelist(df, &#39;from&#39;, &#39;to&#39;) nx.draw(G, with_labels=True) 2.0.1 Matriz de Adyacencia Las gráficas en networkx, las podemos crear también a partir de su matriz de adyacencia. Supongamos que tenemos la siguiente matriz de adyacencia de una gráfica. adjacency_matrix = np.array([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0]]) print(adjacency_matrix) ## [[0 1 1 0] ## [1 0 0 1] ## [1 0 0 0] ## [1 1 0 0]] Vamos a usar esta matriz para crear la gráfica. G = nx.Graph(adjacency_matrix, nodetype=int) print(G.edges()) ## [(0, 1), (0, 2), (0, 3), (1, 3)] nx.draw(G, with_labels=True) Y esta misma matriz, la podríamos usar para generar la red dirigida. G = nx.DiGraph(adjacency_matrix, nodetype=int) print(G.edges()) ## [(0, 1), (0, 2), (1, 0), (1, 3), (2, 0), (3, 0), (3, 1)] nx.draw(G, with_labels=True) 2.0.2 Redes con pesos En muchas aplicaciones, no basta saber si dos nodos están conectados: queremos medir intensidad. Ejemplo: ciudades conectadas por tiempo de traslado. G = nx.Graph() edges = [ (&quot;CDMX&quot;, &quot;Querétaro&quot;, 2.5), (&quot;CDMX&quot;, &quot;Puebla&quot;, 1.8), (&quot;Querétaro&quot;, &quot;San Luis&quot;, 3.0), (&quot;Puebla&quot;, &quot;Veracruz&quot;, 2.2) ] G.add_weighted_edges_from(edges) pos = nx.spring_layout(G, seed=42) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=&quot;lightblue&quot;) labels = nx.get_edge_attributes(G, &quot;weight&quot;) nx.draw_networkx_edge_labels(G, pos, edge_labels=labels) ## {(&#39;CDMX&#39;, &#39;Querétaro&#39;): Text(-0.03804987394440071, 0.29044345796704585, &#39;2.5&#39;), (&#39;CDMX&#39;, &#39;Puebla&#39;): Text(0.03310940855012143, -0.2517211871628955, &#39;1.8&#39;), (&#39;Querétaro&#39;, &#39;San Luis&#39;): Text(-0.09868076835080415, 0.7517180744260015, &#39;3.0&#39;), (&#39;Puebla&#39;, &#39;Veracruz&#39;): Text(0.10107661635624102, -0.7703266027551717, &#39;2.2&#39;)} plt.title(&quot;Red con pesos (horas de traslado)&quot;) plt.show() nx.spring_layout: Cuando dibujas una red, necesitas decidir dónde se coloca cada nodo en el plano (coordenadas (x,y)). nx.spring_layout(G) calcula esas posiciones automáticamente usando un modelo tipo resortes: cada arista actúa como un resorte que “jala” a sus extremos para acercarlos, los nodos se repelen entre sí para que no queden amontonados, el algoritmo busca una configuración “bonita” (pocas intersecciones, distancias razonables). No cambia el grafo, solo produce un diccionario de posiciones. pos = nx.spring_layout(G, seed=42) print(pos) ## {&#39;CDMX&#39;: array([-0.00479153, 0.03721578]), &#39;Querétaro&#39;: array([-0.07130957, 0.54368146]), &#39;Puebla&#39;: array([ 0.07100945, -0.54065133]), &#39;San Luis&#39;: array([-0.12605188, 0.95975409]), &#39;Veracruz&#39;: array([ 0.13114354, -1. ])} Ejercicio: Comparar con nx.circular_layout(G) para ver que “layout” = regla de colocación. 2.0.3 Redes dirigidas En una red dirigida las aristas tienen orientación. Ejemplo: prerequisitos de materias. DG = nx.DiGraph() DG.add_edge(&quot;Álgebra I&quot;, &quot;Álgebra II&quot;) DG.add_edge(&quot;Álgebra II&quot;, &quot;Geometría&quot;) DG.add_edge(&quot;Cálculo I&quot;, &quot;Cálculo II&quot;) pos = nx.spring_layout(DG, seed=10) nx.draw(DG, pos, with_labels=True, node_size=2500, node_color=&quot;lightcoral&quot;, arrows=True, arrowsize=20) plt.title(&quot;Red dirigida (prerrequisitos)&quot;) plt.show() Grado en redes dirigidas In-degree: número de aristas que llegan. Out-degree: número de aristas que salen. print(&quot;In-degree:&quot;, dict(DG.in_degree())) ## In-degree: {&#39;Álgebra I&#39;: 0, &#39;Álgebra II&#39;: 1, &#39;Geometría&#39;: 1, &#39;Cálculo I&#39;: 0, &#39;Cálculo II&#39;: 1} print(&quot;Out-degree:&quot;, dict(DG.out_degree())) ## Out-degree: {&#39;Álgebra I&#39;: 1, &#39;Álgebra II&#39;: 1, &#39;Geometría&#39;: 0, &#39;Cálculo I&#39;: 1, &#39;Cálculo II&#39;: 0} 2.0.4 Graficas acíclicas Un grafo dirigido es acíclico si no contiene ciclos. DAG = nx.DiGraph() DAG.add_edges_from([ (1,2), (1,3), (2,4), (3,4) ]) print(&quot;¿Es DAG?&quot;, nx.is_directed_acyclic_graph(DAG)) ## ¿Es DAG? True Ordenamiento topológico: list(nx.topological_sort(DAG)) ## [1, 2, 3, 4] Si numeramos los vértices según ese orden, la matriz de adyacencia queda triangular superior. En un grafo dirigido sin ciclos, existe un orden de los vértices tal que todas las aristas van “hacia adelante” en ese orden. nx.topological_sort devuelve ese orden. order = list(nx.topological_sort(DAG)) print(order) ## [1, 2, 3, 4] Si reetiquetas/ordenas los vértices según ese orden y construyes la matriz de adyacencia en ese orden, la matriz queda triangular superior. Por ejemplo: DAG = nx.DiGraph() DAG.add_edges_from([(1,2),(1,3),(2,4),(3,4)]) order = list(nx.topological_sort(DAG)) print(&quot;Orden topológico:&quot;, order) ## Orden topológico: [1, 2, 3, 4] A = nx.to_numpy_array(DAG, nodelist=order, dtype=int) print(&quot;Matriz en ese orden:\\n&quot;, A) ## Matriz en ese orden: ## [[0 1 1 0] ## [0 0 0 1] ## [0 0 0 1] ## [0 0 0 0]] A_weird = A.T print(A_weird) ## [[0 0 0 0] ## [1 0 0 0] ## [1 0 0 0] ## [0 1 1 0]] 2.0.5 Redes k-regulares Un grafo es \\(k\\)-regular si todos los vértices tienen grado \\(k\\). R = nx.random_regular_graph(d=3, n=8) nx.draw(R, with_labels=True, node_size=1500) plt.title(&quot;Grafo 3-regular&quot;) plt.show() 2.0.5.1 Multigrafos (multiaristas) En algunos sistemas pueden existir varias relaciones entre dos nodos. Ejemplo: dos actores que colaboran en varias películas. MG = nx.MultiGraph() MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 0 MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 1 MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 2 print(&quot;Número de aristas entre A y B:&quot;, MG.number_of_edges(&quot;A&quot;,&quot;B&quot;)) ## Número de aristas entre A y B: 3 Y para visualziarla: pos = nx.spring_layout(MG, seed=3) nx.draw(MG, pos, with_labels=True, node_size=2000) plt.title(&quot;MultiGraph&quot;) plt.show() Para que se vea que hay varias aristas entre los mismos nodos, usamos connectionstyle con distintos radios. MG = nx.MultiGraph() MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 0 MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 1 MG.add_edge(&quot;A&quot;,&quot;B&quot;) ## 2 MG.add_edge(&quot;B&quot;,&quot;C&quot;) ## 0 pos = nx.spring_layout(MG, seed=2) # Dibujo de nodos nx.draw_networkx_nodes(MG, pos, node_size=2000, node_color=&quot;lightgreen&quot;) nx.draw_networkx_labels(MG, pos) ## {&#39;A&#39;: Text(0.8284668313118051, -0.8726270765014832, &#39;A&#39;), &#39;B&#39;: Text(0.12093500309378266, -0.1273729234985168, &#39;B&#39;), &#39;C&#39;: Text(-0.949401834405588, 1.0, &#39;C&#39;)} # Dibujo de aristas: si son paralelas, usamos curvaturas distintas edges = list(MG.edges(keys=True)) for i, (u, v, k) in enumerate(edges): rad = 0.15 * (i % 3) # radios 0, 0.15, 0.30 (repite) nx.draw_networkx_edges( MG, pos, edgelist=[(u, v)], width=2, connectionstyle=f&quot;arc3,rad={rad}&quot;, edge_color=&quot;gray&quot; ) plt.title(&quot;MultiGraph con multiaristas (arcos curvos)&quot;) plt.axis(&quot;off&quot;) ## (np.float64(-1.0962567812307198), np.float64(0.9571815276728693), np.float64(-1.0082027056679594), np.float64(1.1546815676912536)) plt.show() print(&quot;Número de aristas A-B:&quot;, MG.number_of_edges(&quot;A&quot;,&quot;B&quot;)) ## Número de aristas A-B: 3 2.0.6 Loops (lazos) Un loop es una arista de un nodo a sí mismo. G = nx.Graph() G.add_edge(&quot;A&quot;,&quot;A&quot;) # loop G.add_edge(&quot;A&quot;,&quot;B&quot;) print(&quot;Grados:&quot;, dict(G.degree())) ## Grados: {&#39;A&#39;: 3, &#39;B&#39;: 1} Importante: En grafos no dirigidos, un loop contribuye 2 al grado. NetworkX dibuja loops como “arcos” pequeños, pero a veces quedan discretos. G = nx.Graph() G.add_edges_from([(&quot;A&quot;,&quot;A&quot;), (&quot;A&quot;,&quot;B&quot;), (&quot;B&quot;,&quot;C&quot;), (&quot;C&quot;,&quot;C&quot;)]) # loops en A y C pos = nx.spring_layout(G, seed=4) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=&quot;lightblue&quot;, width=2, edge_color=&quot;gray&quot;) plt.title(&quot;Grafo con loops en A y C&quot;) plt.show() También podemos listarlos: print(&quot;Loops:&quot;, list(nx.selfloop_edges(G))) ## Loops: [(&#39;A&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;C&#39;)] 2.0.7 Redes bipartitas Ejemplo: películas y actores. data = { &quot;Movie&quot;: [&quot;Matrix&quot;,&quot;Matrix&quot;,&quot;Titanic&quot;,&quot;Titanic&quot;,&quot;Inception&quot;], &quot;Actor&quot;: [&quot;Keanu&quot;,&quot;Carrie&quot;,&quot;Leonardo&quot;,&quot;Kate&quot;,&quot;Leonardo&quot;] } df = pd.DataFrame(data) Vamos a construirla: B = nx.Graph() movies = df[&quot;Movie&quot;].unique() actors = df[&quot;Actor&quot;].unique() B.add_nodes_from(movies, bipartite=0) B.add_nodes_from(actors, bipartite=1) B.add_edges_from([(row.Movie,row.Actor) for _,row in df.iterrows()]) nx.draw(B, with_labels=True, node_size=2000) plt.title(&quot;Red bipartita&quot;) plt.show() Otra forma de hacer el plot: pos = nx.bipartite_layout(B, movies) # movies será la capa superior nx.draw(B, pos, with_labels=True, node_size=2000, node_color=&quot;lightblue&quot;) plt.title(&quot;Red bipartita (películas arriba, actores abajo)&quot;) plt.show() Y se puede “forzar” también esto: movies = list(df[&quot;Movie&quot;].unique()) actors = list(df[&quot;Actor&quot;].unique()) pos = {} # Películas arriba (y=1) for i, movie in enumerate(movies): pos[movie] = (i, 1) # Actores abajo (y=0) for i, actor in enumerate(actors): pos[actor] = (i, 0) nx.draw(B, pos, with_labels=True, node_size=2000, node_color=&quot;lightyellow&quot;, edge_color=&quot;gray&quot;) plt.title(&quot;Red bipartita forzada (arriba películas, abajo actores)&quot;) plt.ylim(-0.5, 1.5) ## (-0.5, 1.5) plt.show() Otra forma más, coloreando cada capa: color_map = [] for node in B.nodes(): if node in movies: color_map.append(&quot;lightcoral&quot;) else: color_map.append(&quot;lightblue&quot;) nx.draw(B, pos, with_labels=True, node_color=color_map, node_size=2000) plt.title(&quot;Red bipartita con capas diferenciadas&quot;) plt.show() 2.0.7.1 Matriz de incidencia B_matrix = np.zeros((len(movies), len(actors))) for _,row in df.iterrows(): i = list(movies).index(row.Movie) j = list(actors).index(row.Actor) B_matrix[i,j] = 1 print(B_matrix) ## [[1. 1. 0. 0.] ## [0. 0. 1. 1.] ## [0. 0. 1. 0.]] 2.0.7.2 Proyección one-mode W = B_matrix.T @ B_matrix print(W) ## [[1. 1. 0. 0.] ## [1. 1. 0. 0.] ## [0. 0. 2. 1.] ## [0. 0. 1. 1.]] from networkx.algorithms import bipartite df = pd.DataFrame({ &quot;Movie&quot;: [&quot;Matrix&quot;,&quot;Matrix&quot;,&quot;Titanic&quot;,&quot;Titanic&quot;,&quot;Inception&quot;], &quot;Actor&quot;: [&quot;Keanu&quot;,&quot;Carrie&quot;,&quot;Leonardo&quot;,&quot;Kate&quot;,&quot;Leonardo&quot;] }) movies = list(df[&quot;Movie&quot;].unique()) actors = list(df[&quot;Actor&quot;].unique()) # Grafo bipartito B = nx.Graph() B.add_nodes_from(movies, bipartite=0) B.add_nodes_from(actors, bipartite=1) B.add_edges_from([(row.Movie, row.Actor) for _, row in df.iterrows()]) # Posiciones forzadas (películas arriba, actores abajo) pos = {} for i, m in enumerate(movies): pos[m] = (i, 1) for i, a in enumerate(actors): pos[a] = (i, 0) # Colores por capa node_colors = [&quot;lightcoral&quot; if n in movies else &quot;lightblue&quot; for n in B.nodes()] nx.draw(B, pos, with_labels=True, node_color=node_colors, node_size=2000, edge_color=&quot;gray&quot;) plt.title(&quot;Bipartita: películas (arriba) – actores (abajo)&quot;) ## Text(0.5, 1.0, &#39;Bipartita: películas (arriba) – actores (abajo)&#39;) plt.ylim(-0.6, 1.6) ## (-0.6, 1.6) plt.axis(&quot;off&quot;) ## (np.float64(-0.31500000000000006), np.float64(3.315), np.float64(-0.6), np.float64(1.6)) plt.show() Vamos a crear las dos proyecciones. 2.0.8 Proyección one-mode a Actores # Proyección a actores (one-mode) P_actors = bipartite.weighted_projected_graph(B, actors) print(&quot;Aristas (actor-actor) con pesos:&quot;, list(P_actors.edges(data=True))) ## Aristas (actor-actor) con pesos: [(&#39;Keanu&#39;, &#39;Carrie&#39;, {&#39;weight&#39;: 1}), (&#39;Leonardo&#39;, &#39;Kate&#39;, {&#39;weight&#39;: 1})] posA = nx.spring_layout(P_actors, seed=12) nx.draw(P_actors, posA, with_labels=True, node_size=2000, node_color=&quot;lightblue&quot;, edge_color=&quot;gray&quot;) # Etiquetas de peso labelsA = nx.get_edge_attributes(P_actors, &quot;weight&quot;) nx.draw_networkx_edge_labels(P_actors, posA, edge_labels=labelsA) ## {(&#39;Keanu&#39;, &#39;Carrie&#39;): Text(-0.35775095734238305, 0.19487556024727604, &#39;1&#39;), (&#39;Leonardo&#39;, &#39;Kate&#39;): Text(0.3577635707881759, -0.19487292868700534, &#39;1&#39;)} plt.title(&quot;Proyección one-mode: red de actores (peso = películas compartidas)&quot;) ## Text(0.5, 1.0, &#39;Proyección one-mode: red de actores (peso = películas compartidas)&#39;) plt.axis(&quot;off&quot;) ## (np.float64(-0.9375232965348552), np.float64(1.184108548539511), np.float64(-0.699174762922632), np.float64(1.0700229118070153)) plt.show() 2.0.9 Proyección one-mode a PELÍCULAS # Proyección a películas (one-mode) P_movies = bipartite.weighted_projected_graph(B, movies) print(&quot;Aristas (movie-movie) con pesos:&quot;, list(P_movies.edges(data=True))) ## Aristas (movie-movie) con pesos: [(&#39;Titanic&#39;, &#39;Inception&#39;, {&#39;weight&#39;: 1})] posM = nx.spring_layout(P_movies, seed=12) nx.draw(P_movies, posM, with_labels=True, node_size=2300, node_color=&quot;lightcoral&quot;, edge_color=&quot;gray&quot;) labelsM = nx.get_edge_attributes(P_movies, &quot;weight&quot;) nx.draw_networkx_edge_labels(P_movies, posM, edge_labels=labelsM) ## {(&#39;Titanic&#39;, &#39;Inception&#39;): Text(-0.5000007838353786, -0.32225756924227716, &#39;1&#39;)} plt.title(&quot;Proyección one-mode: red de películas (peso = actores compartidos)&quot;) ## Text(0.5, 1.0, &#39;Proyección one-mode: red de películas (peso = actores compartidos)&#39;) plt.axis(&quot;off&quot;) ## (np.float64(-0.7473488387186665), np.float64(1.0832070875580317), np.float64(-0.6374842965559769), np.float64(0.7055652738076293)) plt.show() Si \\(B\\) es la matriz de incidencia (películas × actores), entonces: \\(B^TB\\): co-ocurrencia actor–actor \\(BB^T\\): co-ocurrencia película–película # Matriz de incidencia: filas=películas, columnas=actores Bmat = np.zeros((len(movies), len(actors)), dtype=int) movie_idx = {m:i for i,m in enumerate(movies)} actor_idx = {a:j for j,a in enumerate(actors)} for _, row in df.iterrows(): Bmat[movie_idx[row.Movie], actor_idx[row.Actor]] = 1 print(&quot;B (películas x actores):\\n&quot;, Bmat) ## B (películas x actores): ## [[1 1 0 0] ## [0 0 1 1] ## [0 0 1 0]] W_actors = Bmat.T @ Bmat # actores x actores W_movies = Bmat @ Bmat.T # películas x películas print(&quot;\\nB^T B (actores x actores):\\n&quot;, W_actors) ## ## B^T B (actores x actores): ## [[1 1 0 0] ## [1 1 0 0] ## [0 0 2 1] ## [0 0 1 1]] print(&quot;\\nB B^T (películas x películas):\\n&quot;, W_movies) ## ## B B^T (películas x películas): ## [[2 0 0] ## [0 2 1] ## [0 1 1]] "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
