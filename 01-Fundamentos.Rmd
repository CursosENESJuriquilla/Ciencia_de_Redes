# Fundamentos de Teoría de Redes

```{r setup1, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r, include=FALSE}
workingDir <-  "."
setwd(workingDir)
```

```{r}
library(reticulate)
```
Primero, tenemos que importar algunas de las librerías básicas. 

- `networkx` es la librería básica de redes en Python.
- `pandas` y `numpy` son básicas para manipulación de bases de datos y arreglos.
- `matplotlib.pyplot` es la básica para hacer plots.

```{python}
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
```

Una de las formas de definir una gráfica en `Python` es crear primero un `objeto` gráfica y después ir agregando los vértices y aristas. Al crear el objeto, se generará una gráfica vacía.

```{python}
G = nx.Graph()
```

Podemos agregar nodos de uno en uno, por medio de una lista y las aristas es similar, podemos especificar entre que nodos están.

```{python}
# Un solo nodo
G.add_node(1)

# Dos nodos como lista
G.add_nodes_from([2,3])

# Arista entre nodo 1 y 2
G.add_edge(1, 2)

# Arista entre nodo 2 y 3
e = (2,3)
G.add_edge(*e)
```


Algo que queremos hacer, es poder visualizar estas gráficas.

```{python}
nx.draw(G, pos=nx.circular_layout(G), node_color='r', edge_color='b', with_labels=True)
```


Vamos a crear otras gráficas.

```{python}
MyGraph = nx.Graph()
MyGraph.add_edge('Antonio', 'Valentina')
MyGraph.add_edge('Antonio', 'Claudia')
MyGraph.add_edge('Claudia','Valentina')
print(MyGraph) # Imprimir información de la gráfica
print('Número de vértices', len(MyGraph.nodes))
print('Número de aristas', len(MyGraph.edges))
nx.draw_networkx(MyGraph, font_size=7)
```

Existen varios atributos que podemos usar para dibujar la red. Por ejemplo:`nx.draw_circular, nx.draw_planar, nx.draw_random, nx.draw_spectral, nx.draw_spring, nx.draw_shell`.

```{python}
nx.draw_planar(MyGraph, with_labels = True, font_size=10, node_color='red', edge_color='blue')
```

Vamos a construir una red simétrica. Los pesos pueden añadir intensidad de la relación en los nodos, cada arista tendrá un peso. Para gráficas dirigidas se usa `nx.DiGraph()`.

```{python}
DG = nx.DiGraph()

# Agregamos nodos y aristas
DG.add_nodes_from(["A", "B", "C"])
DG.add_edges_from([("A", "B"), ("B", "C")])

# Dibujamos la gráfica
nx.draw_networkx(DG, font_size=7)
```


Y podemos crear una gráfica con pesos como sigue.

```{python}
WG = nx.Graph()

# Agregamos nodos y aristas
WG.add_edge("A", "B", weight=3)
WG.add_edge("B", "C", weight=2)
WG.add_edge("C", "A", weight=1)

# Dibujamos la gráfica
nx.draw_networkx(WG, font_size=7)
```

Sin embargo, si queremos que salga el peso, hay que modificar la forma de dibujarla.

```{python}
WG2 = nx.Graph()
WG2.add_node("A", pos=(1,1))
WG2.add_node("B", pos=(2,2))
WG2.add_node("C", pos=(1,0))

WG2.add_edge("A","B",weight=0.5)
WG2.add_edge("A","C",weight=9.8)
pos=nx.get_node_attributes(WG2,'pos')
nx.draw(WG2,pos)
labels = nx.get_edge_attributes(WG2,'weight')
nx.draw_networkx_edge_labels(WG2,pos,edge_labels=labels)
```


Si tenemos ya una base de datos, vista como un data frame, podemos construir su gráfica también tomando la información de esta.

```{python}
df = pd.DataFrame({ 'from':['A', 'B', 'C','A'], 'to':['D', 'A', 'E','C']})
G=nx.from_pandas_edgelist(df, 'from', 'to')
nx.draw(G, with_labels=True)
```


## Matriz de Adyacencia

Las gráficas en `networkx`, las podemos crear también a partir de su matriz de adyacencia.

Supongamos que tenemos la siguiente matriz de adyacencia de una gráfica.

```{python}
adjacency_matrix = np.array([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0]])
print(adjacency_matrix)
```

Vamos a usar esta matriz para crear la gráfica.

```{python}
G = nx.Graph(adjacency_matrix, nodetype=int)
print(G.edges())
nx.draw(G, with_labels=True)
```

Y esta misma matriz, la podríamos usar para generar la red dirigida.

```{python}
G = nx.DiGraph(adjacency_matrix, nodetype=int)
print(G.edges())
nx.draw(G, with_labels=True)
```

## Redes con pesos

En muchas aplicaciones, no basta saber si dos nodos están conectados: queremos medir intensidad.

Ejemplo: ciudades conectadas por tiempo de traslado.

```{python}
G = nx.Graph()

edges = [
    ("CDMX", "Querétaro", 2.5),
    ("CDMX", "Puebla", 1.8),
    ("Querétaro", "San Luis", 3.0),
    ("Puebla", "Veracruz", 2.2)
]

G.add_weighted_edges_from(edges)

pos = nx.spring_layout(G, seed=42)

nx.draw(G, pos, with_labels=True, node_size=2000, node_color="lightblue")
labels = nx.get_edge_attributes(G, "weight")
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

plt.title("Red con pesos (horas de traslado)")
plt.show()
```

`nx.spring_layout`: Cuando dibujas una red, necesitas decidir dónde se coloca cada nodo en el plano (coordenadas (x,y)). `nx.spring_layout(G)` calcula esas posiciones automáticamente usando un modelo tipo resortes: 

- cada arista actúa como un resorte que “jala” a sus extremos para acercarlos,

- los nodos se repelen entre sí para que no queden amontonados,

- el algoritmo busca una configuración “bonita” (pocas intersecciones, distancias razonables).

No cambia el grafo, solo produce un diccionario de posiciones.

```{python}
pos = nx.spring_layout(G, seed=42)
print(pos)
```

**Ejercicio:** Comparar con `nx.circular_layout(G)` para ver que “layout” = regla de colocación.

## Redes dirigidas

En una red dirigida las aristas tienen orientación.

Ejemplo: prerequisitos de materias.

```{python}
DG = nx.DiGraph()

DG.add_edge("Álgebra I", "Álgebra II")
DG.add_edge("Álgebra II", "Geometría")
DG.add_edge("Cálculo I", "Cálculo II")

pos = nx.spring_layout(DG, seed=10)

nx.draw(DG, pos,
        with_labels=True,
        node_size=2500,
        node_color="lightcoral",
        arrows=True,
        arrowsize=20)

plt.title("Red dirigida (prerrequisitos)")
plt.show()
```

**Grado en redes dirigidas**

- *In-degree*: número de aristas que llegan.

- *Out-degree*: número de aristas que salen.

```{python}
print("In-degree:", dict(DG.in_degree()))
print("Out-degree:", dict(DG.out_degree()))
```

## Graficas acíclicas

Un grafo dirigido es acíclico si no contiene ciclos.

```{python}
DAG = nx.DiGraph()
DAG.add_edges_from([
    (1,2),
    (1,3),
    (2,4),
    (3,4)
])

print("¿Es DAG?", nx.is_directed_acyclic_graph(DAG))
```

Ordenamiento topológico:

```{python}
list(nx.topological_sort(DAG))
```

Si numeramos los vértices según ese orden, la matriz de adyacencia queda triangular superior.

En un grafo dirigido sin ciclos, existe un orden de los vértices tal que todas las aristas van “hacia adelante” en ese orden. `nx.topological_sort` devuelve ese orden.

```{python}
order = list(nx.topological_sort(DAG))
print(order)
```

Si reetiquetas/ordenas los vértices según ese orden y construyes la matriz de adyacencia en ese orden, la matriz queda triangular superior. Por ejemplo:

```{python}
DAG = nx.DiGraph()
DAG.add_edges_from([(1,2),(1,3),(2,4),(3,4)])

order = list(nx.topological_sort(DAG))
print("Orden topológico:", order)

A = nx.to_numpy_array(DAG, nodelist=order, dtype=int)
print("Matriz en ese orden:\n", A)

A_weird = A.T
print(A_weird)
```


## Redes k-regulares

Un grafo es $k$-regular si todos los vértices tienen grado $k$.

```{python}
R = nx.random_regular_graph(d=3, n=8)

nx.draw(R, with_labels=True, node_size=1500)
plt.title("Grafo 3-regular")
plt.show()
```

## Multigrafos (multiaristas)

En algunos sistemas pueden existir varias relaciones entre dos nodos.

Ejemplo: dos actores que colaboran en varias películas.

```{python}
MG = nx.MultiGraph()

MG.add_edge("A","B")
MG.add_edge("A","B")
MG.add_edge("A","B")

print("Número de aristas entre A y B:",
      MG.number_of_edges("A","B"))
```

Y para visualziarla:

```{python}
pos = nx.spring_layout(MG, seed=3)
nx.draw(MG, pos, with_labels=True, node_size=2000)
plt.title("MultiGraph")
plt.show()
```


Para que se vea que hay varias aristas entre los mismos nodos, usamos connectionstyle con distintos radios.

```{python}
MG = nx.MultiGraph()
MG.add_edge("A","B")
MG.add_edge("A","B")
MG.add_edge("A","B")
MG.add_edge("B","C")

pos = nx.spring_layout(MG, seed=2)

# Dibujo de nodos
nx.draw_networkx_nodes(MG, pos, node_size=2000, node_color="lightgreen")
nx.draw_networkx_labels(MG, pos)

# Dibujo de aristas: si son paralelas, usamos curvaturas distintas
edges = list(MG.edges(keys=True))
for i, (u, v, k) in enumerate(edges):
    rad = 0.15 * (i % 3)  # radios 0, 0.15, 0.30 (repite)
    nx.draw_networkx_edges(
        MG, pos,
        edgelist=[(u, v)],
        width=2,
        connectionstyle=f"arc3,rad={rad}",
        edge_color="gray"
    )

plt.title("MultiGraph con multiaristas (arcos curvos)")
plt.axis("off")
plt.show()

print("Número de aristas A-B:", MG.number_of_edges("A","B"))
```

## Loops (lazos)

Un loop es una arista de un nodo a sí mismo.

```{python}
G = nx.Graph()
G.add_edge("A","A")  # loop
G.add_edge("A","B")

print("Grados:", dict(G.degree()))
```

Importante:

En grafos no dirigidos, un loop contribuye 2 al grado.

NetworkX dibuja loops como “arcos” pequeños, pero a veces quedan discretos.

```{python}
G = nx.Graph()
G.add_edges_from([("A","A"), ("A","B"), ("B","C"), ("C","C")])  # loops en A y C

pos = nx.spring_layout(G, seed=4)

nx.draw(G, pos, with_labels=True, node_size=2000, node_color="lightblue",
        width=2, edge_color="gray")

plt.title("Grafo con loops en A y C")
plt.show()
```

También podemos listarlos:

```{python}
print("Loops:", list(nx.selfloop_edges(G)))
```

## Redes bipartitas

Ejemplo: películas y actores.

```{python}
data = {
    "Movie": ["Matrix","Matrix","Titanic","Titanic","Inception"],
    "Actor": ["Keanu","Carrie","Leonardo","Kate","Leonardo"]
}

df = pd.DataFrame(data)
```

Vamos a construirla:

```{python}
B = nx.Graph()

movies = df["Movie"].unique()
actors = df["Actor"].unique()

B.add_nodes_from(movies, bipartite=0)
B.add_nodes_from(actors, bipartite=1)

B.add_edges_from([(row.Movie,row.Actor)
                  for _,row in df.iterrows()])

nx.draw(B, with_labels=True, node_size=2000)
plt.title("Red bipartita")
plt.show()
```

Otra forma de hacer el plot:

```{python}
pos = nx.bipartite_layout(B, movies)  # movies será la capa superior

nx.draw(B, pos,
        with_labels=True,
        node_size=2000,
        node_color="lightblue")

plt.title("Red bipartita (películas arriba, actores abajo)")
plt.show()
```

Y se puede "forzar" también esto:

```{python}
movies = list(df["Movie"].unique())
actors = list(df["Actor"].unique())

pos = {}

# Películas arriba (y=1)
for i, movie in enumerate(movies):
    pos[movie] = (i, 1)

# Actores abajo (y=0)
for i, actor in enumerate(actors):
    pos[actor] = (i, 0)

nx.draw(B, pos,
        with_labels=True,
        node_size=2000,
        node_color="lightyellow",
        edge_color="gray")

plt.title("Red bipartita forzada (arriba películas, abajo actores)")
plt.ylim(-0.5, 1.5)
plt.show()
```

Otra forma más, coloreando cada capa:

```{python}
color_map = []

for node in B.nodes():
    if node in movies:
        color_map.append("lightcoral")
    else:
        color_map.append("lightblue")

nx.draw(B, pos,
        with_labels=True,
        node_color=color_map,
        node_size=2000)

plt.title("Red bipartita con capas diferenciadas")
plt.show()
```

### Matriz de incidencia

```{python}
B_matrix = np.zeros((len(movies), len(actors)))

for _,row in df.iterrows():
    i = list(movies).index(row.Movie)
    j = list(actors).index(row.Actor)
    B_matrix[i,j] = 1

print(B_matrix)
```

### Proyección one-mode

```{python}
W = B_matrix.T @ B_matrix
print(W)
```

```{python}
from networkx.algorithms import bipartite

df = pd.DataFrame({
    "Movie": ["Matrix","Matrix","Titanic","Titanic","Inception"],
    "Actor": ["Keanu","Carrie","Leonardo","Kate","Leonardo"]
})

movies = list(df["Movie"].unique())
actors = list(df["Actor"].unique())

# Grafo bipartito
B = nx.Graph()
B.add_nodes_from(movies, bipartite=0)
B.add_nodes_from(actors, bipartite=1)
B.add_edges_from([(row.Movie, row.Actor) for _, row in df.iterrows()])

# Posiciones forzadas (películas arriba, actores abajo)
pos = {}
for i, m in enumerate(movies):
    pos[m] = (i, 1)
for i, a in enumerate(actors):
    pos[a] = (i, 0)

# Colores por capa
node_colors = ["lightcoral" if n in movies else "lightblue" for n in B.nodes()]

nx.draw(B, pos, with_labels=True, node_color=node_colors, node_size=2000, edge_color="gray")
plt.title("Bipartita: películas (arriba) – actores (abajo)")
plt.ylim(-0.6, 1.6)
plt.axis("off")
plt.show()
```

Vamos a crear las dos proyecciones.

### Proyección one-mode a Actores

```{python}


# Proyección a actores (one-mode)
P_actors = bipartite.weighted_projected_graph(B, actors)

print("Aristas (actor-actor) con pesos:", list(P_actors.edges(data=True)))

posA = nx.spring_layout(P_actors, seed=12)
nx.draw(P_actors, posA, with_labels=True, node_size=2000, node_color="lightblue", edge_color="gray")

# Etiquetas de peso
labelsA = nx.get_edge_attributes(P_actors, "weight")
nx.draw_networkx_edge_labels(P_actors, posA, edge_labels=labelsA)

plt.title("Proyección one-mode: red de actores (peso = películas compartidas)")
plt.axis("off")
plt.show()
```

### Proyección one-mode a PELÍCULAS

```{python}
# Proyección a películas (one-mode)
P_movies = bipartite.weighted_projected_graph(B, movies)

print("Aristas (movie-movie) con pesos:", list(P_movies.edges(data=True)))

posM = nx.spring_layout(P_movies, seed=12)
nx.draw(P_movies, posM, with_labels=True, node_size=2300, node_color="lightcoral", edge_color="gray")

labelsM = nx.get_edge_attributes(P_movies, "weight")
nx.draw_networkx_edge_labels(P_movies, posM, edge_labels=labelsM)

plt.title("Proyección one-mode: red de películas (peso = actores compartidos)")
plt.axis("off")
plt.show()
```

Si $B$ es la matriz de incidencia (películas × actores), entonces:

- $B^TB$: co-ocurrencia actor–actor

- $BB^T$: co-ocurrencia película–película


```{python}
# Matriz de incidencia: filas=películas, columnas=actores
Bmat = np.zeros((len(movies), len(actors)), dtype=int)

movie_idx = {m:i for i,m in enumerate(movies)}
actor_idx = {a:j for j,a in enumerate(actors)}

for _, row in df.iterrows():
    Bmat[movie_idx[row.Movie], actor_idx[row.Actor]] = 1

print("B (películas x actores):\n", Bmat)

W_actors = Bmat.T @ Bmat   # actores x actores
W_movies = Bmat @ Bmat.T   # películas x películas

print("\nB^T B (actores x actores):\n", W_actors)
print("\nB B^T (películas x películas):\n", W_movies)
```


## Árboles

En Python, podemos crear árboles con la instrucción `nx.path_graph(n)`

```{python}
T = nx.path_graph(6)
nx.draw(T, with_labels=True)
```

Podemos verificar si una gráfica dada es un árbol, al verificar la condición de que $|E| = |V|-1$.

```{python}
n = T.number_of_nodes()
m = T.number_of_edges()

print("Nodos:", n)
print("Aristas:", m)
print("¿Cumple m = n-1?", m == n-1)
```

**Ejercicio:** Genera un `cycle_graph(6)`. Verifica si es un árbol. Elimina una arista y vuelve a verificar.

Veamos otros algoritmos de `networkx` para generar árboles.

- `prefix_tree`: Un "árbol de prefijos" representa la estructura de prefijos de las cadenas. Cada nodo representa un prefijo de alguna cadena. La raíz representa el prefijo vacío con hijos para los prefijos de una sola letra, que a su vez tienen hijos para cada prefijo de dos letras, comenzando con la letra correspondiente al nodo padre, y así sucesivamente. Añade artificialmente dos nodos, el nodo raíz y el nodo `NIL`. El nodo raíz siempre es 0 y su atributo de origen es "Ninguno". Es el único nodo con grado de entrada cero. El nodo nulo siempre es -1 y su atributo de origen es "NIL". Es el único nodo con grado de salida cero.

```{python}
paths = ["ab", "abs", "ad"]
T = nx.prefix_tree(paths)
list(T.edges)
```

```{python}
nx.draw(T, with_labels= True)
```

```{python}
nx.is_tree(T)
```

```{python}
T.remove_node(-1)
nx.draw(T, with_labels= True)
nx.is_tree(T)
```

Podemos recuperar las trayectorias que teníamos.

```{python}
paths = ["ab", "abs", "ad"]
T = nx.prefix_tree(paths)
root, NIL = 0, -1

recovered = []
for v in T.predecessors(NIL):
    prefix = ""
    while v != root:
        prefix = str(T.nodes[v]["source"]) + prefix
        v = next(T.predecessors(v))  # only one predecessor
    recovered.append(prefix)
sorted(recovered)
```

- `random_labeled_tree`:

```{python}
G = nx.random_labeled_tree(5, seed=42)
nx.is_tree(G)
nx.draw(G, with_labels = True)
```

```{python}
DG = nx.DiGraph()
DG.add_edges_from(G.edges)
nx.is_tree(DG)
nx.draw(DG, with_labels = True)
```

- `random_labeled_rooted_forest`:

```{python}
F = nx.random_labeled_rooted_forest(10, seed = 42)
nx.is_forest(F)
nx.draw(F, with_labels = True)
```

- `random_unlabeled_rooted_forest`

```{python}
#F2 = nx.random_unlabeled_rooted_forest(10, number_of_forests=3, seed = 42)
#nx.is_forest(F2)
#nx.draw(F2, with_labels = True)
```

## Gráficas planas

Con la función `nx.check_planarity(Graph_object)` podemos verificar si una red es plana o no.

```{python}
G1 = nx.cycle_graph(5)
nx.check_planarity(G1)
```

```{python}
G2 = nx.complete_graph(6)
nx.draw(G2, with_labels=True)
is_planar, P = nx.check_planarity(G2, counterexample=True)
```

```{python}
print(is_planar)
nx.draw(P, with_labels=True)
```

**Ejercicio:** Verifica la planaridad de `complete_graph(4)` y `complete_graph(5)`.

## Grado y grado medio

```{python}
G = nx.cycle_graph(6)
dict(G.degree())
```

```{python}
G.degree[1]
```

El grado medio lo podemos obtener de la siguiente forma:

```{python}
deg_values = [d for n,d in G.degree()]
c = np.mean(deg_values)
print("EL grado medio c es igual a ", c)
```

Teóricamente, el grado medio cumple que $c=\frac{2m}{n}$, donde $m$ es el número de aristas y $n$ el número de vértices.

```{python}
n = G.number_of_nodes()
m = G.number_of_edges()
v = 2*m/n
print('Se cumple la relación c=2m/n', c == v)
```


**Ejercicio:** Crea una `complete_graph(8)`, calcula el grado medio y comparalo con la fórmula teórica.

## Densidad

Para una red no dirigida, tenemos lo siguiente:

```{python}
G = nx.path_graph(10)
nx.density(G)
```

Para el caso de una red dirigida,

```{python}
DG = nx.DiGraph()
DG.add_edges_from([(1,2),(2,3),(3,4)])
nx.density(DG)
```

**Ejemplo:** Compara la desidad de las gráficas `path_graph(20)` y `complete_graph(20)`. ¿Cuál es sparse y cuál densa?

### Sparsidad y crecimiento

```{python}
for n in [20,50,100]:
   G = nx.path_graph(n)
   print("n =", n, "densidad =", nx.density(G))
```


## Redes multicapa

```{python}
G = nx.Graph()

G.add_edge("Ana","Luis", layer="amistad")
G.add_edge("Ana","Luis", layer="trabajo")

G.edges(data=True)

nx.draw(G)
```

**Ejercicio:** ¿Cómo cambiaría el grado si consideramos cada capa por separado?


## Redes dinámicas

```{python}
G_t1 = nx.Graph()
G_t1.add_edges_from([(1,2),(2,3)])

G_t2 = nx.Graph()
G_t2.add_edges_from([(1,2),(2,4)])

print("Densidad t1:", nx.density(G_t1))
print("Densidad t2:", nx.density(G_t2))
```

## Caminos y trayectorias

```{python}
G = nx.Graph()
G.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])

nx.draw(G, with_labels=True)
```

Podemos listas todos los posibles caminos simples(sin vértices repetidos):

```{python}
list(nx.all_simple_paths(G, source=1, target=5))
```

Se puede demostrar que que un camino simple se puede encontrar en tiempo $O(V+E)$ pero el número de trayectorias simples puede ser muy grande, por ejemplo para gráficas completas de orden $n$ es de tiempo $O(n!)$.

Uno puede especificar trayectorias de longitud $r$ como sigue:

```{python}
G = nx.complete_graph(4)
paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2)
print(list(paths))
```

Y podemos obtenerlas también como la lista de aristas:

```{python}
paths = nx.all_simple_paths(G, source=0, target=3)
for path in map(nx.utils.pairwise, paths):
    print(list(path))
```

Podríamos también fijar solo uno de los nodos y el otro variarlo:

```{python}
G = nx.complete_graph(4)
for path in nx.all_simple_paths(G, source=0, target=[3, 2]):
    print(path)
```

La trayectoria que va de un vértice a si mismo de tamaño 0:

```{python}
G = nx.empty_graph(5)
list(nx.all_simple_paths(G, source=0, target=0))
```

```{python}
G = nx.path_graph(3)
list(nx.all_simple_paths(G, source=0, target={0, 1, 2}))
```

Podemos contar las trayectorias de una raíz a sus hojas en una gráfica dirigida acíclica.
```{python}
G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])
roots = (v for v, d in G.in_degree() if d == 0)
leaves = (v for v, d in G.out_degree() if d == 0)
all_paths = []
for root in roots:
    for leaf in leaves:
        paths = nx.all_simple_paths(G, root, leaf)
        all_paths.extend(paths)
all_paths
```

Iterar sobre cada ruta desde los nodos raíz a los nodos hoja en un gráfico acíclico dirigido pasando todas las hojas juntas para evitar cálculos innecesarios:

```{python}
G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)])
roots = (v for v, d in G.in_degree() if d == 0)
leaves = [v for v, d in G.out_degree() if d == 0]
all_paths = []
for root in roots:
    paths = nx.all_simple_paths(G, root, leaves)
    all_paths.extend(paths)
all_paths
```

En las multigráficas, es decir si tenemos aristas paralelas, nos va a regresar las trayectorias múltiple veces:

```{python}
G = nx.MultiDiGraph([(0, 1), (0, 1), (1, 2)])
list(nx.all_simple_paths(G, 0, 2))
```


Como decíamos antes, el tiempo en el que encuentra caminos simples puede ser muy grande, entonces es recomendado preguntarse primero si existen caminos entre dos nodos.

```{python}
G1 = nx.Graph()
G1.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])
nx.has_path(G1, 1, 4)
```

```{pyton}
G2 = nx.Graph()
G2.add_edges_from([(1, 2), (2, 3), (4, 5)])

# nodo 1 y nodo 3 
path_exists_1_to_3 = nx.has_path(G2, 1, 3)
print(f"Existe una trayectoria de 1 a 3: {path_exists_1_to_3}")

# Nodo 1 y nodo 4 
path_exists_1_to_4 = nx.has_path(G2, 1, 4)
print(f"Existe una trayectoria de 1 a 4: {path_exists_1_to_4}")
```

**Ejercicio:** Construye una red que no tenga un camino entre dos nodos dados. Y usa la función `has_path()` para verificarlo.

## Trayectorias más cortas

```{python}
G1 = nx.Graph()
G1.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])
nx.shortest_path(G1, source=1, target=4)
```

```{python}
G1 = nx.Graph()
G1.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])
nx.shortest_path_length(G1, source=1, target=4)
```

Para el caso de gráficas con peso:

```{python}
WG = nx.Graph()
WG.add_weighted_edges_from([
 (1,2,1),
   (2,3,2),
   (1,3,5),
   (3,4,1)
])

nx.shortest_path(WG, source=1, target=4, weight="weight")
```

**Ejercicio:** Modifica los pesos para que cambie el camino más corto.

## Componentes conexas

```{python}
G = nx.Graph()
G.add_edges_from([(1,2),(2,3),(4,5)])

nx.draw(G, with_labels=True)
```

```{python}
list(nx.connected_components(G))
```

```{python}
nx.number_connected_components(G)
```

Para el caso de redes dirigidas, tenemos una forma de preguntar por las debilmente conectadas y las fuertemente conectadas.

```{python}
DG = nx.DiGraph()
DG.add_edges_from([
   (1,2),
   (2,3),
   (3,1),
   (3,4),
   (5,4)
])
```


```{python}
list(nx.weakly_connected_components(DG))
```

```{python}
list(nx.strongly_connected_components(DG))
```

Y para las In y Out componentes también:

- `descendants(G, source)`: nos regresa todos los vértices que son alcanzables desde algún vértice `source`.

- `ancestors(G, source)`: nos regresa todos los vértices que tienen una trayectoria al vértice `source`.

```{python}
nx.descendants(DG, 1)
nx.ancestors(DG, 1)
```

## Trayectorias independientes

- Independientes por aristas:

```{python}
G1 = nx.Graph()
G1.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])
nx.edge_disjoint_paths(G1, 1, 4)
```

```{python}
G1 = nx.Graph()
G1.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])
list(nx.edge_disjoint_paths(G1, 1, 4))
```

- Independientes por vértices:

```{python}
G1 = nx.Graph()
G1.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])
list(nx.node_disjoint_paths(G1, 1, 4))
```

## Conjuntos de corte

- Conjunto de corte por aristas mínimo:

```{python}
G1 = nx.Graph()
G1.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])
nx.minimum_edge_cut(G1, 1, 4)
```

- Conjunto de corte por vértices mínimo:

```{python}
G1 = nx.Graph()
G1.add_edges_from([
   (1,2),
   (2,3),
   (3,4),
   (2,4),
   (4,5)
])
nx.minimum_node_cut(G1, 1, 4)
```

